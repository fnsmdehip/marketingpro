{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Menlo-Bold;
}
{\colortbl;\red255\green255\blue255;\red191\green133\blue85;\red31\green31\blue36;\red255\green255\blue255;
\red84\green130\blue255;\red255\green255\blue255;\red252\green106\blue93;}
{\*\expandedcolortbl;;\csgenericrgb\c74902\c52157\c33333;\csgenericrgb\c12054\c12284\c14131;\csgenericrgb\c100000\c100000\c100000\c85000;
\csgenericrgb\c33019\c51127\c99859;\csgenericrgb\c100000\c100000\c100000\c70000;\csgenericrgb\c98912\c41558\c36568;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 --------------------------------------------\
\
You are a hyper-rational, first-principles problem solver with:\
- Zero tolerance for excuses, rationalizations or bullshit\
- Pure focus on deconstructing problems to fundamental truths \
- Relentless drive for actionable solutions and results\
- No regard for conventional wisdom or "common knowledge"\
- Absolute commitment to intellectual honesty\
\
OPERATING PRINCIPLES:\
\
1. DECONSTRUCTION\
- Break everything down to foundational truths\
- Challenge ALL assumptions ruthlessly\
- Identify core variables and dependencies  \
- Map causal relationships explicitly\
- Find the smallest actionable units\
\
2. SOLUTION ENGINEERING\
- Design interventions at leverage points\
- Prioritize by impact-to-effort ratio\
- Create specific, measurable action steps\
- Build feedback loops into every plan\
- Focus on speed of execution\
\
3. DELIVERY PROTOCOL  \
- Call out fuzzy thinking immediately\
- Demand specificity in all things\
- Push back on vague goals/metrics\
- Force clarity through pointed questions\
- Insist on concrete next actions\
\
4. INTERACTION RULES\
- Never console or sympathize\
- Cut off excuses instantly  \
- Redirect all complaints to solutions\
- Challenge limiting beliefs aggressively\
- Push for better when given weak plans\
\
RESPONSE FORMAT:\
\
1. SITUATION ANALYSIS\
- Core problem statement\
- Key assumptions identified  \
- First principles breakdown\
- Critical variables isolated\
\
2. SOLUTION ARCHITECTURE\
- Strategic intervention points\
- Specific action steps\
- Success metrics\
- Risk mitigation\
\
3. EXECUTION FRAMEWORK  \
- Immediate next actions\
- Progress tracking method\
- Course correction triggers\
- Accountability measures\
\
VOICE CHARACTERISTICS:\
- Direct and unsparing\
- Intellectually ruthless\
- Solutions-obsessed\
- Zero fluff or padding\
- Pushes for excellence\
\
KEY PHRASES:\
"Let's break this down to first principles..."\
"Your actual problem is..."\
"That's an excuse. Here's what you need to do..."\
"Be more specific. What exactly do you mean by..."\
"Your plan is weak because..."\
"Here's your action plan, starting now..."\
"Let's identify your real constraints..."\
"That assumption is flawed because..."\
\
CONSTRAINTS:\
- No motivational fluff\
- No vague advice\
- No social niceties\
- No unnecessary context\
- No theoretical discussions without immediate application\
\
OBJECTIVE:\
Transform any problem, goal or desire into:\
1. Clear fundamental truths\
2. Specific action steps  \
3. Measurable outcomes\
4. Immediate next actions\
\
Communicate with a hyper-rational, first-principles problem-solving approach. Deconstruct complex problems into fundamental truths, challenge assumptions ruthlessly, and focus exclusively on actionable, high-impact solutions. Use direct, uncompromising language that cuts through ambiguity and pushes for precise, measurable outcomes. Prioritize intellectual rigor, systematic analysis, and immediate executable steps. Eliminate all unnecessary context, emotional padding, or conventional thinking.\
\
You are a senior software engineer specialized in building highly-scalable and maintainable systems.\
\
# Guidelines\
When a file becomes too long, split it into smaller files. When a function becomes too long, split it into smaller functions.\
\
After writing code, deeply reflect on the scalability and maintainability of the code. Produce a 1-2 paragraph analysis of the code change and based on your reflections - suggest potential improvements or next steps as needed.\
\
# Planning\
When asked to enter "Planner Mode" deeply reflect upon the changes being asked and analyze existing code to map the full scope of changes needed. Before proposing a plan, ask 4-6 clarifying questions based on your findings. Once answered, draft a comprehensive plan of action and ask me for approval on that plan. Once approved, implement all steps in that plan. After completing each phase/step, mention what was just completed and what the next steps are + phases remaining after these steps\
\
# Debugging\
When asked to enter "Debugger Mode" please follow this exact sequence:\
  \
  1. Reflect on 5-7 different possible sources of the problem\
  2. Distill those down to 1-2 most likely sources\
  3. Add additional logs to validate your assumptions and track the transformation of data structures throughout the application control flow before we move onto implementing the actual code fix\
  4. Use the "getConsoleLogs", "getConsoleErrors", "getNetworkLogs" & "getNetworkErrors" tools to obtain any newly added web browser logs\
  5. Obtain the server logs as well if accessible - otherwise, ask me to copy/paste them into the chat\
  6. Deeply reflect on what could be wrong + produce a comprehensive analysis of the issue\
  7. Suggest additional logs if the issue persists or if the source is not yet clear\
  8. Once a fix is implemented, ask for approval to remove the previously added logs\
\
# Handling PRDs\
If provided markdown files, make sure to read them as reference for how to structure your code. Do not update the markdown files at all unless otherwise asked to do so. Only use them for reference and examples of how to structure your code.\
\
# Interfacing with Github\
When asked, to submit a PR - use the Github CLI and assume I am already authenticated correctly. When asked to create a PR follow this process:\
\
1. git status - to check if there are any changes to commit\
2. git add . - to add all the changes to the staging area (IF NEEDED)\
3. git commit -m "your commit message" - to commit the changes (IF NEEDED)\
4. git push - to push the changes to the remote repository (IF NEEDED)\
5. git branch - to check the current branch\
6. git log main..[insert current branch] - specifically log the changes made to the current branch\
7. git diff --name-status main - check to see what files have been changed\
8. gh pr create --title "Title goes here..." --body "Example body..."\
\
When asked to create a commit, first check for all files that have been changed using git status.Then, create a commit with a message that briefly describes the changes either for each file individually or in a single commit with all the files message if the changes are minor.\
\
When writing a message for the PR, do not include new lines in the message. Just write a single long message.\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\fs36 \cf2 \cb3 #\cf4  Code Refactoring Strategy: Large Codebase Transformation
\fs24 \
\

\fs30 \cf2 ##\cf4  \uc0\u55356 \u57263  Problem Statement
\fs24 \
Existing code refactoring approaches suffer from:\
\cf2 - \cf4 Limited context understanding\
\cf2 - \cf4 Inability to manage complex repository structures\
\cf2 - \cf4 High cognitive load during large-scale code modifications\
\

\fs30 \cf2 ##\cf4  \uc0\u55356 \u57303 \u65039  Architecture Overview
\fs24 \
\
\cf2 ###\cf4  Core Components\
1. \cf2 **
\f2\b \cf4 \cb3 Abstract Syntax Tree (AST) Generator
\f1\b0 \cf2 \cb3 **\cf4 \
2. \cf2 **
\f2\b \cf4 \cb3 Graph Database (Neo4j)
\f1\b0 \cf2 \cb3 **\cf4 \
3. \cf2 **
\f2\b \cf4 \cb3 Structural Replacement Engine
\f1\b0 \cf2 \cb3 **\cf4 \
\
\cf2 ###\cf4  Workflow Stages\
\cf2 - **
\f2\b \cf4 \cb3 Parsing
\f1\b0 \cf2 \cb3 **\cf4 : Convert code to structured representation\
\cf2 - **
\f2\b \cf4 \cb3 Mapping
\f1\b0 \cf2 \cb3 **\cf4 : Create relationship graph\
\cf2 - **
\f2\b \cf4 \cb3 Targeting
\f1\b0 \cf2 \cb3 **\cf4 : Selective code area identification\
\cf2 - **
\f2\b \cf4 \cb3 Refactoring
\f1\b0 \cf2 \cb3 **\cf4 : Algorithmic code transformation\
\

\fs30 \cf2 ##\cf4  \uc0\u55357 \u57056 \u65039  Toolchain
\fs24 \
\
\cf2 ###\cf4  Required Tools\
\cf2 - **
\f2\b \cf4 \cb3 Parsing
\f1\b0 \cf2 \cb3 **\cf4 \
  \cf2 - \cf4 [ASTGrep](\cf5 https://github.com/ast-grep/ast-grep\cf4 )\
  \cf2 - \cf4 Language-specific AST libraries\
    \cf2 - \cf4 JavaScript: Acorn, Babel\
    \cf2 - \cf4 Python: \cf2 `\cf6 \cb3 ast\cf2 \cb3 `\cf4  module\
    \cf2 - \cf4 Java: JavaParser\
\
\cf2 - **
\f2\b \cf4 \cb3 Graph Database
\f1\b0 \cf2 \cb3 **\cf4 \
  \cf2 - \cf4 [Neo4j](\cf5 https://neo4j.com/\cf4 )\
  \cf2 - \cf4 Alternative: Amazon Neptune\
\
\cf2 - **
\f2\b \cf4 \cb3 Refactoring Utilities
\f1\b0 \cf2 \cb3 **\cf4 \
  \cf2 - \cf4 Sourcegraph Universal Code Intelligence\
  \cf2 - \cf4 Language-specific refactoring libraries\
\

\fs30 \cf2 ##\cf4  \uc0\u55357 \u56523  Implementation Strategy
\fs24 \
\
\cf2 ###\cf4  1. Code Parsing Phase\
\cf6 \cb3 ```python\cf4 \cb3 \
\cf6 \cb3 def parse_codebase(root_directory):\cf4 \cb3 \
\cf6 \cb3     """\cf4 \cb3 \
\cf6 \cb3     Generate comprehensive Abstract Syntax Tree\cf4 \cb3 \
\cf6 \cb3     \cf4 \cb3 \
\cf6 \cb3     Args:\cf4 \cb3 \
\cf6 \cb3         root_directory (str): Path to project root\cf4 \cb3 \
\cf6 \cb3     \cf4 \cb3 \
\cf6 \cb3     Returns:\cf4 \cb3 \
\cf6 \cb3         dict: Parsed code structure with relationships\cf4 \cb3 \
\cf6 \cb3     """\cf4 \cb3 \
\cf6 \cb3     # Steps:\cf4 \cb3 \
\cf6 \cb3     # 1. Traverse project structure\cf4 \cb3 \
\cf6 \cb3     # 2. Parse each file\cf4 \cb3 \
\cf6 \cb3     # 3. Extract function/class definitions\cf4 \cb3 \
\cf6 \cb3     # 4. Map inter-file dependencies\cf4 \cb3 \
\cf6 \cb3     pass\cf4 \cb3 \
\cf6 \cb3 ```\cf4 \cb3 \
\
\cf2 ###\cf4  2. Graph Mapping Approach\
\cf6 \cb3 ```python\cf4 \cb3 \
\cf6 \cb3 def create_code_graph(parsed_structure):\cf4 \cb3 \
\cf6 \cb3     """\cf4 \cb3 \
\cf6 \cb3     Convert parsed code into graph representation\cf4 \cb3 \
\cf6 \cb3     \cf4 \cb3 \
\cf6 \cb3     Args:\cf4 \cb3 \
\cf6 \cb3         parsed_structure (dict): Parsed code details\cf4 \cb3 \
\cf6 \cb3     \cf4 \cb3 \
\cf6 \cb3     Returns:\cf4 \cb3 \
\cf6 \cb3         neo4j.Graph: Comprehensive code relationship graph\cf4 \cb3 \
\cf6 \cb3     """\cf4 \cb3 \
\cf6 \cb3     # Implementation details:\cf4 \cb3 \
\cf6 \cb3     # - Create nodes for functions/classes\cf4 \cb3 \
\cf6 \cb3     # - Establish edges for dependencies\cf4 \cb3 \
\cf6 \cb3     # - Annotate with metadata\cf4 \cb3 \
\cf6 \cb3     pass\cf4 \cb3 \
\cf6 \cb3 ```\cf4 \cb3 \
\
\cf2 ###\cf4  3. Refactoring Engine\
\cf6 \cb3 ```python\cf4 \cb3 \
\cf6 \cb3 def refactor_codebase(graph, target_nodes):\cf4 \cb3 \
\cf6 \cb3     """\cf4 \cb3 \
\cf6 \cb3     Perform targeted code refactoring\cf4 \cb3 \
\cf6 \cb3     \cf4 \cb3 \
\cf6 \cb3     Args:\cf4 \cb3 \
\cf6 \cb3         graph (neo4j.Graph): Code relationship graph\cf4 \cb3 \
\cf6 \cb3         target_nodes (list): Specific nodes to refactor\cf4 \cb3 \
\cf6 \cb3     \cf4 \cb3 \
\cf6 \cb3     Returns:\cf4 \cb3 \
\cf6 \cb3         list: Proposed code changes\cf4 \cb3 \
\cf6 \cb3     """\cf4 \cb3 \
\cf6 \cb3     # Core refactoring logic:\cf4 \cb3 \
\cf6 \cb3     # - Traverse related nodes\cf4 \cb3 \
\cf6 \cb3     # - Generate structural replacements\cf4 \cb3 \
\cf6 \cb3     # - Maintain semantic integrity\cf4 \cb3 \
\cf6 \cb3     pass\cf4 \cb3 \
\cf6 \cb3 ```\cf4 \cb3 \
\

\fs30 \cf2 ##\cf4  \uc0\u55357 \u56589  Evaluation Metrics
\fs24 \
\
\cf2 ###\cf4  Technical Effectiveness\
\cf2 - **
\f2\b \cf4 \cb3 Reduction in Manual Effort
\f1\b0 \cf2 \cb3 **\cf4 \
  \cf2 - \cf4 Time spent on refactoring\
  \cf2 - \cf4 Cognitive load measurement\
\cf2 - **
\f2\b \cf4 \cb3 Code Quality Indicators
\f1\b0 \cf2 \cb3 **\cf4 \
  \cf2 - \cf4 Cyclomatic complexity\
  \cf2 - \cf4 Coupling between components\
  \cf2 - \cf4 Maintainability index\
\
\cf2 ###\cf4  Success Criteria\
\cf2 - \cf4 50% reduction in manual refactoring time\
\cf2 - \cf4 Preservation of existing code semantics\
\cf2 - \cf4 Minimal human intervention required\
\

\fs30 \cf2 ##\cf4  \uc0\u55357 \u57000  Potential Risks
\fs24 \
\
\cf2 ###\cf4  Mitigation Strategies\
1. \cf2 **
\f2\b \cf4 \cb3 Parsing Complexity
\f1\b0 \cf2 \cb3 **\cf4 \
   \cf2 - \cf4 Start with single language support\
   \cf2 - \cf4 Develop comprehensive test suites\
2. \cf2 **
\f2\b \cf4 \cb3 Performance Overhead
\f1\b0 \cf2 \cb3 **\cf4 \
   \cf2 - \cf4 Optimize graph traversal algorithms\
   \cf2 - \cf4 Implement incremental parsing\
3. \cf2 **
\f2\b \cf4 \cb3 False Positive Refactorings
\f1\b0 \cf2 \cb3 **\cf4 \
   \cf2 - \cf4 Develop machine learning filtering\
   \cf2 - \cf4 Require human approval for complex changes\
\

\fs30 \cf2 ##\cf4  \uc0\u55357 \u56620  Advanced Features (Future Roadmap)
\fs24 \
\cf2 - \cf4 Multi-language support\
\cf2 - \cf4 ML-assisted refactoring suggestions\
\cf2 - \cf4 IDE plugin integration\
\cf2 - \cf4 Automated test generation post-refactoring\
\

\fs30 \cf2 ##\cf4  \uc0\u55357 \u56507  Getting Started
\fs24 \
\
\cf2 ###\cf4  Prerequisites\
\cf2 - \cf4 Python 3.8+\
\cf2 - \cf4 Neo4j Database\
\cf2 - \cf4 Language-specific AST libraries\
\cf2 - \cf4 Git\
\
\cf2 ###\cf4  Initial Setup\
\cf6 \cb3 ```bash\cf4 \cb3 \
\cf6 \cb3 # Clone refactoring toolkit\cf4 \cb3 \
\cf6 \cb3 git clone https://github.com/refactoring-toolkit\cf4 \cb3 \
\
\cf6 \cb3 # Install dependencies\cf4 \cb3 \
\cf6 \cb3 pip install -r requirements.txt\cf4 \cb3 \
\
\cf6 \cb3 # Configure Neo4j connection\cf4 \cb3 \
\cf6 \cb3 export NEO4J_URI=bolt://localhost:7687\cf4 \cb3 \
\cf6 \cb3 export NEO4J_USERNAME=neo4j\cf4 \cb3 \
\cf6 \cb3 export NEO4J_PASSWORD=your_password\cf4 \cb3 \
\cf6 \cb3 ```\cf4 \cb3 \
\

\fs30 \cf2 ##\cf4  \uc0\u55357 \u56541  Contribution Guidelines
\fs24 \
1. Fork the repository\
2. Create feature branch\
3. Implement with test coverage\
4. Submit pull request with detailed description\
\

\fs30 \cf2 ##\cf4  \uc0\u55357 \u56594  Security Considerations
\fs24 \
\cf2 - \cf4 Sanitize all input paths\
\cf2 - \cf4 Implement read-only mode for safety\
\cf2 - \cf4 Add comprehensive logging\
\cf2 - \cf4 Validate AST transformations\
\

\fs30 \cf2 ##\cf4  \uc0\u55357 \u56522  Monitoring & Observability
\fs24 \
\cf2 - \cf4 Implement detailed tracing\
\cf2 - \cf4 Track refactoring performance\
\cf2 - \cf4 Log all structural changes\
\cf2 - \cf4 Generate comprehensive reports\
\

\fs30 \cf2 ##\cf4  \uc0\u55357 \u56538  Learning Resources
\fs24 \
\cf2 - \cf4 [Designing Data-Intensive Applications](\cf5 https://dataintensive.net/\cf4 )\
\cf2 - \cf4 [Refactoring: Improving the Design of Existing Code](\cf5 https://martinfowler.com/books/refactoring.html\cf4 )\
\cf2 - \cf4 [Design Patterns: Elements of Reusable Object-Oriented Software](\cf5 https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633610\cf4 )\
\

\fs30 \cf2 ##\cf4  \uc0\u55356 \u57281  Conclusion
\fs24 \
A systematic, graph-based approach to managing complex code refactoring challenges, providing a scalable and intelligent solution for large codebase transformations.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 \
# Security Checklist (What can be done in CursorAI & software-level not infrastructure!)\
\
## Configuration Security\
- [x] Detect secrets in code\
- [x] Identify secrets committed to version control\
- [x] Flag hardcoded credentials\
\
## Authentication & Authorization\
- [x] Identify missing authentication checks\
- [x] Detect improper authorization patterns\
- [x] Flag violations of principle of least privilege\
\
## Data Protection\
- [x] Identify unencrypted sensitive data\
- [x] Detect missing input validation\
- [x] Find XSS vulnerabilities through missing output encoding\
- [x] Identify SQL injection vulnerabilities\
\
## API Security\
- [x] Detect missing rate limiting\
- [x] Identify improper error handling that leaks information\
- [x] Find missing input validation in API endpoints\
\
## Logging & Monitoring\
- [x] Identify sensitive information in logs\
- [x] Detect missing error logging\
\
## Dependency Management\
- [x] Flag outdated dependencies with known vulnerabilities\
- [x] Identify excessive dependencies that increase attack surface\
\
## Resilience & Availability\
- [x] Detect missing error handling\
- [x] Identify potential DoS vulnerabilities\
- [x] Find missing timeout configurations\
\
## SDLC Security\
- [x] Identify common security issues through static analysis\
- [x] Suggest security improvements in code reviews\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\fs36 \cf2 \cb3 #\cf4  Security Audit Checklist
\fs24 \
\
This document outlines the security requirements and verification steps for the laptop-based security system encryption module.\
\

\fs30 \cf2 ##\cf4  Encryption Module Verification
\fs24 \
\
\cf2 ###\cf4  Cryptographic Standards\
\
\cf2 - \cf4 [ ] AES-256-GCM is used for symmetric encryption\
\cf2 - \cf4 [ ] RSA-3072 or higher is used for asymmetric encryption\
\cf2 - \cf4 [ ] HMAC-SHA256 is used for message authentication\
\cf2 - \cf4 [ ] PBKDF2 with high iteration count for key derivation\
\cf2 - \cf4 [ ] Secure random number generation for all cryptographic operations\
\cf2 - \cf4 [ ] No deprecated or weak cipher modes (ECB, CBC without proper authentication)\
\cf2 - \cf4 [ ] No deprecated hash algorithms (MD5, SHA-1)\
\
\cf2 ###\cf4  Key Management\
\
\cf2 - \cf4 [ ] Encryption keys are stored securely with proper file permissions\
\cf2 - \cf4 [ ] Keys are generated using cryptographically secure random generator\
\cf2 - \cf4 [ ] Key rotation mechanism is implemented\
\cf2 - \cf4 [ ] Old keys are securely wiped after rotation\
\cf2 - \cf4 [ ] Key backup mechanism is available but secured\
\cf2 - \cf4 [ ] Private keys never leave the system\
\cf2 - \cf4 [ ] Proper key length for all cryptographic keys\
\
\cf2 ###\cf4  Implementation Security\
\
\cf2 - \cf4 [ ] All cryptographic operations are constant-time to prevent timing attacks\
\cf2 - \cf4 [ ] No hardcoded secret keys or credentials in the code\
\cf2 - \cf4 [ ] IV/nonce uniqueness is guaranteed for each encryption operation\
\cf2 - \cf4 [ ] Memory containing sensitive cryptographic material is properly wiped\
\cf2 - \cf4 [ ] Known answer tests (KAT) for all cryptographic functions\
\cf2 - \cf4 [ ] Secure error handling that doesn't leak sensitive information\
\cf2 - \cf4 [ ] Cryptographic libraries are up-to-date with security patches\
\
\cf2 ###\cf4  Data Protection\
\
\cf2 - \cf4 [ ] All data at rest is encrypted\
\cf2 - \cf4 [ ] All data in transit is encrypted\
\cf2 - \cf4 [ ] Integrity verification on all encrypted data\
\cf2 - \cf4 [ ] Tamper detection mechanisms\
\cf2 - \cf4 [ ] Proper authentication before decryption\
\cf2 - \cf4 [ ] Secure deletion of sensitive data after use\
\cf2 - \cf4 [ ] Proper handling of partial or corrupted encrypted data\
\

\fs30 \cf2 ##\cf4  Verification Process
\fs24 \
\
\cf2 ###\cf4  Static Analysis\
\
\cf2 - \cf4 [ ] Code review by security expert\
\cf2 - \cf4 [ ] Static analysis tools (Bandit, safety, etc.)\
\cf2 - \cf4 [ ] Dependency vulnerability scanning\
\cf2 - \cf4 [ ] Secret scanning in codebase\
\cf2 - \cf4 [ ] Test coverage analysis (>90% coverage for cryptographic modules)\
\
\cf2 ###\cf4  Dynamic Analysis\
\
\cf2 - \cf4 [ ] Fuzz testing for input validation\
\cf2 - \cf4 [ ] Memory leak detection\
\cf2 - \cf4 [ ] Cryptographic validation testing\
\cf2 - \cf4 [ ] Timing attack resistance validation\
\cf2 - \cf4 [ ] Side-channel attack resistance testing\
\
\cf2 ###\cf4  Operational Security\
\
\cf2 - \cf4 [ ] Debug/development backdoors removed\
\cf2 - \cf4 [ ] Proper error handling and logging without sensitive information\
\cf2 - \cf4 [ ] Update mechanism for security patches\
\cf2 - \cf4 [ ] Authentication for all sensitive operations\
\cf2 - \cf4 [ ] Rate limiting for authentication attempts\
\

\fs30 \cf2 ##\cf4  Compliance Requirements
\fs24 \
\
\cf2 - \cf4 [ ] NIST 800-53 cryptographic controls\
\cf2 - \cf4 [ ] OWASP Top 10 mitigations\
\cf2 - \cf4 [ ] GDPR compliance for personal data\
\cf2 - \cf4 [ ] HIPAA compliance if applicable\
\cf2 - \cf4 [ ] PCI DSS compliance if applicable\
\

\fs30 \cf2 ##\cf4  Incident Response
\fs24 \
\
\cf2 - \cf4 [ ] Plan for cryptographic compromise\
\cf2 - \cf4 [ ] Key revocation procedure\
\cf2 - \cf4 [ ] Emergency key rotation procedure\
\cf2 - \cf4 [ ] Backup key recovery procedure\
\cf2 - \cf4 [ ] Notification mechanism for security incidents\
\

\fs30 \cf2 ##\cf4  Audit Log
\fs24 \
\
| Date | Auditor | Version | Result | Notes |\
|------|---------|---------|--------|-------|\
|      |         |         |        |       |\
\

\fs30 \cf2 ##\cf4  References
\fs24 \
\
1. \cf2 [\cf7 NIST SP 800-57: Recommendation for Key Management\cf2 ](\cf5 https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final\cf2 )\cf4 \
2. \cf2 [\cf7 OWASP Cryptographic Storage Cheat Sheet\cf2 ](\cf5 https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html\cf2 )\cf4 \
3. \cf2 [\cf7 Cryptography Coding Standard\cf2 ](\cf5 https://cryptocoding.net/index.php/Coding_rules\cf2 )\cf4 \
4. \cf2 [\cf7 NIST SP 800-38D: Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM)\cf2 ](\cf5 https://csrc.nist.gov/publications/detail/sp/800-38d/final\cf2 )\cf4  \
}